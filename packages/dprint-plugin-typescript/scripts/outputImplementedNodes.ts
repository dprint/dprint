import { createProject } from "./createProject";
import { BabelAnalyzer, BabelNode } from "./babel";
import { DPrintAnalyzer } from "./dprint";
import { BabelNodeProperty } from "./babel/BabelNodeProperty";

const project = createProject();
const babelAnalyzer = new BabelAnalyzer(project);
const dprintAnalyzer = new DPrintAnalyzer(project);
const fileSystem = project.getFileSystem();

const implementedTypes = new Set(dprintAnalyzer.getParserParseObjKeys());
const flowNodeNames = new Set(dprintAnalyzer.getIgnoredFlowNodeNames());
const ignoredNodeNames = new Set(dprintAnalyzer.getIgnoredUnknownNodeNames());
const implementedNodes: BabelNode[] = [];
const unImplementedNodes: BabelNode[] = [];

for (const node of babelAnalyzer.getNodes().filter(n => !flowNodeNames.has(n.getName()) && !ignoredNodeNames.has(n.getName()))) {
    if (node.isReferenced() || implementedTypes.has(node.getType()) && verifyNodeHasNoProperties(node))
        implementedNodes.push(node);
    else
        unImplementedNodes.push(node);
}

let output = `# Implemented Nodes\n\n`;
output += `This file is automatically generated with the help of [ts-morph](https://github.com/dsherret/ts-morph).\n\n`;

outputHeader("Implemented", implementedNodes);

for (const node of implementedNodes) {
    output += `* ${node.getName()}\n`;
    for (const prop of node.getProperties()) {
        if (isAllowedProperty(prop))
            outputProperty(prop);
    }
}

output += "\n";

outputHeader("Not implemented", unImplementedNodes);

for (const node of unImplementedNodes)
    output += `* ${node.getName()}\n`;

fileSystem.writeFileSync("implemented-nodes.md", output);

function verifyNodeHasNoProperties(node: BabelNode) {
    const props = node.getProperties().filter(p => p.getName() !== "type");
    if (props.length > 0)
        throw new Error(`The node '${node.getName()}' was expected to have no properties, but it did: ${props.map(p => p.getName()).join(", ")}`);

    return true;
}

function outputHeader(header: string, nodes: BabelNode[], additionalText?: string) {
    output += `## ${header}\n\n`;
    if (additionalText != null)
        output += additionalText + "\n\n";
    output += `**Total:** ${nodes.length}\n\n`;
}

function outputProperty(prop: BabelNodeProperty) {
    output += `    * ${prop.isReferenced() ? ":heavy_check_mark:" : ":x:"} ${prop.getName()}\n`;
}

function isAllowedProperty(prop: BabelNodeProperty) {
    switch (prop.getName()) {
        case "type":
            return false;
    }

    return true;
}
